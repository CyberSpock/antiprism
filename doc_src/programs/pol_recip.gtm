#define HL_PROG class=curpage

#include "<<HEAD>>"
#include "<<START>>"


<<TITLE_HEAD>>

<<TOP_LINKS>>

<<USAGE_START>>
<pre class="prog_help">
<<__SYSTEM__(../src/<<BASENAME>> -h > tmp.txt)>>
#entities ON
#include "tmp.txt"
#entities OFF
</pre>
<<USAGE_END>>


<<EXAMPLES_START>>
Make a reciprocal pair. Make the dual of a cuboctahedron, a rhombic
dodecahedron, and then make the dual of that. The final output is
the same as the original cuboctahedron.
<<CMDS_START>>
pol_recip -o rh_dodec.off cuboct.off<br>
pol_recip -o orig_cuboct.off rh_dodec.off
<<CMDS_END>>

Make a cube whose vertices are the mid-points of an octahedron's faces
<<CMDS_START>>
pol_recip -o cube.off -R f octahedron.off
<<CMDS_END>>

A polyhedron has a face made of vertices with indexes 0, 2, 4.
Make a dual which has a vertex in the plane of this face
<<CMDS_START>>
pol_recip -o dual.off -R 0,2,4 poly.off
<<CMDS_END>>
<<EXAMPLES_END>>


<<NOTES_START>>
A dual of a convex polyhedron is normally made with the centre of
reciprocation at the polyhedron centre and the radius to just touch
the edges.
<p>
Some polyhedra have faces passing through their natural centre. This
causes a problem when making a dual because the vertex which is dual
to this face should be infinitely far away. <i>pol_recip</i> allows these
vertices to be included by placing them at a specified (probably very large)
distance normal to the face. Any programs dealing with these distant vertices
(e.g. povray) can interpret these distant vertices accordingly.
<p>
The default reciprocation centre and radius are found by the following
algorithm. It aims to find a reciprocation sphere that is <i>balanced</i>,
in the sense that the polyhedron and its dual have the same relationship
with the sphere.

<pre>
   centre = centroid of vertices of base polyhedron
   radius = average distance from centre to edges
   LOOP:
      dual = polar reciprocal of base, using centre and radius
      
      invert dual in centre point

      edge_centroid    = centroid of the nearest points to the centre
                         on the base's edges and duals edges
      radius_sum_base  = sum of distances from the centre to the nearest
                         point to the centre on the base's edges
      radius_sum_dual  = sum of distances from the centre to the nearest
                         point to the centre on the dual's edges

      if loop count is even:
         centre = 0.9*centre + 0.1*edge_centroid
      if loop count is odd:
         radius = radius * sqrt(rad_sum_g/rad_sum_d)

      finish loop if change in centre and radius are small enough

</pre>
<p>
The aim is that this will be a <i>similar reciprocation</i> method.
That is to say
<ul>
<li>It will be <i>reciprocal</i> - it will always reciprocate a polyhedron
    into the same polyhedron dual, and it will always reciprocate the dual
    into the original polyhedron
<li>It will <i>respect similarity</i> - similar polyhedra will have similar
    dual-pairs and similar duals
</ul>
<p>
The default method above tends to reciprocate in the midsphere, if
it exists.
<p>
The other available balanced reciprocation methods use the centroid
of combined face near-points and vertex offsets, or the centroid
of the near-points of all three elements combined. For all three
cases the dual may be inverted in the reciprocation centre before
the centroid calculation.
<p>
<i>-R e</i> may select a sphere suitable for self-duality.
<p>
<i>-R v</i> and <i>-R V</i> may always give the same results.
<<NOTES_END>>

#include "<<END>>"
