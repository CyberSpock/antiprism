#define HL_PROG class=curpage

<<__SYSTEM__(help2man -s 1 -n "<<TITLE_CURRENT>>" -N --include man_extra.txt ../src/<<BASENAME>>  > ../doc/man/<<BASENAME>>.1 )>>

#include "<<HEAD>>"
#include "<<START>>"


<H1><<TITLE_CURRENT>></H1>

<<CONT_S_START>>
<SMALL><A HREF="#usage">Usage</A></SMALL>
<<BARSPACE>>
<SMALL><A HREF="#examples">Examples</A></SMALL>
<<BARSPACE>>
<SMALL><A HREF="#notes">Notes</A></SMALL>
<<CONT_S_END>>


<H2><A NAME="usage">
Usage
</A></H2>

<PRE>
<<__SYSTEM__(../src/<<BASENAME>> -h > tmp.txt)>>
#entities ON
#include "tmp.txt"
#entities OFF
</PRE>


<H2><A NAME="examples">
Examples
</A></H2>
Make a reciprocal pair. Make the dual of a cuboctahedron, a rhombic
dodecahedron, and then make the dual of that. The final output is
the same as the original cuboctahedron.
<PRE>
   pol_recip -o rh_dodec.off cuboct.off<BR>
   pol_recip -o orig_cuboct.off rh_dodec.off
</PRE>

Make a cube whose vertices are the mid-points of an octahedron's faces
<PRE>
   pol_recip -o cube.off -R f octahedron.off
</PRE>

A polyhedron has a face made of vertices with indexes 0, 2, 4.
Make a dual which has a vertex in the plane of this face
<PRE>
   pol_recip -o dual.off -R 0,2,4 poly.off
</PRE>


<H2><A NAME="notes">
Notes
</A></H2>

A dual of a convex polyhedron is normally made with the centre of
reciprocation at the polyhedron centre and the radius to just touch
the edges.
<P>
Some polyhedra have faces passing through their natural centre. This
causes a problem when making a dual because the vertex which is dual
to this face should be infinitely far away. <I>pol_recip</I> allows these
vertices to be included by placing them at a specified (probably very large)
distance normal to the face. Any programs dealing with these distant vertices
(e.g. povray) can interpret these distant vertices accordingly.
<P>
The default reciprocation centre and radius are found by the following
algorithm. It aims to find a reciprocation sphere that is <I>balanced</I>,
in the sense that the polyhedron and its dual have the same relationship
with the sphere.

<PRE>
   centre = centroid of vertices of base polyhedron
   radius = average distance from centre to edges
   LOOP:
      dual = polar reciprocal of base, using centre and radius
      
      invert dual in centre point

      edge_centroid    = centroid of the nearest points to the centre
                         on the base's edges and duals edges
      radius_sum_base  = sum of distances from the centre to the nearest
                         point to the centre on the base's edges
      radius_sum_dual  = sum of distances from the centre to the nearest
                         point to the centre on the dual's edges

      if loop count is even:
         centre = 0.9*centre + 0.1*edge_centroid
      if loop count is odd:
         radius = radius * sqrt(rad_sum_g/rad_sum_d)

      finish loop if change in centre and radius are small enough

</PRE>
<P>
The aim is that this will be a <I>similar reciprocation</I> method.
That is to say
<UL>
<LI>It will be <I>reciprocal</I> - it will always reciprocate a polyhedron
    into the same polyhedron dual, and it will always reciprocate the dual
    into the original polyhedron
<LI>It will <I>respect similarity</I> - similar polyhedra will have similar
    dual-pairs and similar duals
</UL>
<P>
The default method above tends to reciprocate in the midsphere, if
it exists.
<P>
The other available balanced reciprocation methods use the centroid
of combined face near-points and vertex offsets, or the centroid
of the near-points of all three elements combined. For all three
cases the dual may be inverted in the reciprocation centre before
the centroid calculation.
<P>
<I>-R e</I> may select a sphere suitable for self-duality.
<P>
<I>-R v</I> and <I>-R V</I> may always give the same results.


#include "<<END>>"
